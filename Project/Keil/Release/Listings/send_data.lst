C51 COMPILER V9.60.7.0   SEND_DATA                                                         05/24/2025 16:58:02 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SEND_DATA
OBJECT MODULE PLACED IN .\Release\Objects\send_data.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\send_data.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X0
                    -00C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Rel
                    -ease\Listings\send_data.lst) OBJECT(.\Release\Objects\send_data.obj)

line level    source

   1          #include "send_data.h"
   2          
   3          void send_data(u8 instruct, u32 send_data)
   4          {
   5   1          u32 check_num = 0; // 存放校验和
   6   1      
   7   1          uart0_sendbyte(FORMAT_HEAD); // 先发送格式头
   8   1      
   9   1          check_num += FORMAT_HEAD; // 使用if()语句时，才使用这一条程序
  10   1      
  11   1          if (SEND_GEAR == instruct ||                /* 发送挡位的状态 */
  12   1              SEND_BATTERY == instruct ||             /* 发送电池电量的状态 */
  13   1              SEND_BARKE == instruct ||               /* 发送刹车的状态 */
  14   1              SEND_LEFT_TURN == instruct ||           /* 发送左转向灯的状态 */
  15   1              SEND_RIGHT_TURN == instruct ||          /* 发送右转向灯的状态 */
  16   1              SEND_HIGH_BEAM == instruct ||           /* 发送远光灯的状态 */
  17   1              SEND_FUEL == instruct ||                /* 发送油量 */
  18   1              SEND_WATER_TEMP == instruct ||          /* 发送水温 */
  19   1              SEND_TEMP_OF_WATER_ALERT == instruct || /* 发送水温报警 */
  20   1              SEND_MALFUNCTION_STATUS == instruct || /* 发送故障的状态 */ 
  21   1              SEND_ABS_STATUS == instruct /* 发送ABS的状态 */ 
  22   1          )    // 如果指令的总长度只有5个字节
  23   1          {
  24   2              uart0_sendbyte(0x05);     // 发送指令的总长度
  25   2              uart0_sendbyte(instruct); // 发送指令
  26   2              uart0_sendbyte(send_data);
  27   2      
  28   2              check_num += 0x05 + (u8)instruct + (u8)send_data;
  29   2          }
  30   1          else if (SEND_ENGINE_SPEED == instruct ||     /* 发送发动机的转速 */
  31   1                   SEND_SPEED == instruct ||            /* 发送时速 */
  32   1                   SEND_SUBTOTAL_MILEAGE == instruct || /* 发送小计里程 */
  33   1                   SEND_TOUCH_KEY_STATUS == instruct || /* 发送触摸按键的状态 */
  34   1                   SEND_VOLTAGE_OF_BATTERY == instruct  /* 发送电池电压 */
  35   1                   )                                    // 如果指令的总长度为6个字节
  36   1          {
  37   2              uart0_sendbyte(0x06);           // 发送指令的总长度
  38   2              uart0_sendbyte(instruct);       // 发送指令
  39   2              uart0_sendbyte(send_data >> 8); // 发送信息
  40   2              uart0_sendbyte(send_data);      // 发送信息
  41   2      
  42   2              check_num += 0x06 + (u8)instruct + (u8)(send_data >> 8) + (u8)(send_data);
  43   2          }
  44   1          else if (SEND_TOTAL_MILEAGE == instruct || /* 发送大计里程 */
  45   1                   SEND_TIME == instruct             /* 发送时间 */
  46   1                   )                                 // 如果指令的总长度为7个字节
  47   1          {
  48   2      
  49   2              uart0_sendbyte(0x07);     // 发送指令的总长度
  50   2              uart0_sendbyte(instruct); // 发送指令
  51   2      
  52   2              uart0_sendbyte(send_data >> 16); // 发送信息
  53   2              uart0_sendbyte(send_data >> 8);  // 发送信息
C51 COMPILER V9.60.7.0   SEND_DATA                                                         05/24/2025 16:58:02 PAGE 2   

  54   2              uart0_sendbyte(send_data);       // 发送信息
  55   2      
  56   2              check_num += 0x07 + (u8)instruct + (u8)(send_data >> 16) + (u8)(send_data >> 8) + (u8)send_data;
  57   2          }
  58   1          else if (SEND_DATE == instruct /* 发送日期(年月日) */
  59   1                   )                     // 如果指令的总长度为8个字节
  60   1          {
  61   2              uart0_sendbyte(0x08);     // 发送指令的总长度
  62   2              uart0_sendbyte(instruct); // 发送指令
  63   2      
  64   2              uart0_sendbyte(send_data >> 24); // 发送信息
  65   2              uart0_sendbyte(send_data >> 16); // 发送信息
  66   2              uart0_sendbyte(send_data >> 8);  // 发送信息
  67   2              uart0_sendbyte(send_data);       // 发送信息
  68   2      
  69   2              check_num += 0x08 + (u8)instruct + (u8)(send_data >> 24) + (u8)(send_data >> 16) + (u8)(send_data 
             ->> 8) + (u8)send_data;
  70   2          }
  71   1      
  72   1          // check_num &= 0x0F;         // 取前面的数字相加的低四位
  73   1          check_num &= 0xFF;         // 取前面的数字相加的低八位
  74   1          uart0_sendbyte(check_num); // 发送校验和
  75   1      
  76   1          delay_ms(1);
  77   1          // delay_ms(10); // 每次发送完成后，延时10ms
  78   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    533    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
