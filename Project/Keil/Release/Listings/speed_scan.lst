C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        05/20/2025 17:55:59 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) 
                    -INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\
                    -Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          // 多少个脉冲表示一圈
   4          #ifndef SPEED_SCAN_PULSE_PER_TURN
              #define SPEED_SCAN_PULSE_PER_TURN (16)
              #endif // 多少个脉冲表示一圈
   7          
   8          // 车轮一圈表示多少毫米
   9          #ifndef SPEED_SCAN_MM_PER_TURN
              #define SPEED_SCAN_MM_PER_TURN (1795) // 一圈1795毫米
              #endif                                // 车轮一圈表示多少毫米
  12          
  13          // 标志位，是否由更新计数,由定时器来置位
  14          // 0--未更新脉冲计数，1--有新的脉冲计数
  15          volatile bit flag_is_update_speed_pulse_cnt = 0;
  16          volatile u16 speed_scan_time_cnt = 0;        // 速度扫描时，用到的时间计数值，会在定时
             -中断中累加
  17          volatile u16 speed_actual_scan_time_cnt = 0; // 存放实际的速度扫描时间(实际的速度扫描用
             -时)
  18          // volatile u32 detect_speed_pulse_cnt = 0; // 检测时速的脉冲计数值
  19          /*
  20              存放 检测到的时速脉冲计数值，会在中断内累加
  21              使用了双缓冲，[0]用在定时器中断中，[1]用在处理函数中
  22              当 flag_is_update_speed_pulse_cnt == 1时，说明已经有数据更新
  23          */
  24          volatile u32 detect_speed_pulse_cnt[2] = {0}; // 检测时速的脉冲计数值
  25          
  26          // 时速扫描的配置
  27          void speed_scan_config(void)
  28          {
  29   1      #if 1 // 使用定时器扫描IO电平变化来计算脉冲
  30   1          
  31   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x3); // 输入模式
  32   1          P1_PU |= GPIO_P15_PULL_UP(0x1);    // 配置为上拉
  33   1      
  34   1      #endif // 使用定时器扫描IO电平变化来计算脉冲
  35   1      }
  36          
  37          // 速度扫描函数
  38          void speed_scan(void)
  39          {
  40   1          volatile u32 cur_speed = 0;                    // 记录当前采集到的速度
  41   1          static volatile u32 cur_speed_average_val = 0; // 存放当前速度的平均值(单位：km/h)
  42   1      
  43   1          static volatile u8 speed_scan_cnt = 0;
  44   1      
  45   1          if (flag_is_update_speed_pulse_cnt) // 如果有数据更新
  46   1          {
  47   2              flag_is_update_speed_pulse_cnt = 0;
  48   2              /*
  49   2                  计算 xx ms内走过了多少毫米
  50   2                  xx ms内走过了多少毫米 == 当前扫描时间内检测到的脉冲个数 / 车轮一圈
             -应多少个脉冲 * 一圈对应 xx 毫米
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        05/20/2025 17:55:59 PAGE 2   

  51   2                  换成单片机可以计算的形式：
  52   2                  xx ms内走过了多少毫米 == 当前扫描时间内检测到的脉冲个数 * 一圈对应 
             -xx 毫米 / 车轮一圈对应多少个脉冲
  53   2              */
  54   2              cur_speed = detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN;
  55   2      
  56   2              // printf("cur pulse cnt %lu \n", detect_speed_pulse_cnt[1]); // 临时测试用
  57   2      
  58   2              detect_speed_pulse_cnt[1] = 0; // 清空脉冲计数
  59   2              distance += cur_speed;         // 存放走过的距离，单位：毫米
  60   2      
  61   2              /*
  62   2                  已知在扫描时间内走过了xx mm
  63   2                  时速的计算公式:
  64   2                  扫描时间内走过的距离 / 1000 * (1 / 扫描时间对1s的占比) * 3.6
  65   2                      扫描时间内走过的距离 / 1000，转换成 m/扫描时间 的单位
  66   2                      * (1 / 扫描时间对1s的占比)，转换成以s为单位的速度
  67   2                      * 3.6，因为 1m/s == 3.6km/h，最后转换成 以km/h的单位
  68   2                  转换成单片机可以计算的形式：
  69   2                  时速 == 扫描时间内走过的距离 * 36 * (1 / 扫描时间对1s的占比) / 10000；
  70   2      
  71   2                  逐渐变换成单片机可以计算的形式：
  72   2                  cur_speed = cur_speed * 36 * (1 / (SPEED_SCAN_TIME_MS / 1000)) / 10000;
  73   2                  cur_speed = cur_speed * 36 * 1000 / SPEED_SCAN_TIME_MS / 10000;
  74   2                  cur_speed = cur_speed * 36 / SPEED_SCAN_TIME_MS / 10;
  75   2              */
  76   2              cur_speed = (cur_speed * 36) / speed_actual_scan_time_cnt / 10;
  77   2      
  78   2              // printf("cur speed %lu \n", cur_speed);
  79   2      
  80   2              if (speed_scan_cnt < SPEED_SCAN_FILTER_CNT)
  81   2              {
  82   3                  // 如果未达到重复检测的次数
  83   3                  speed_scan_cnt++;
  84   3                  cur_speed_average_val += cur_speed; // 累加当前得到的时速(单位：km/h)
  85   3      
  86   3                  // if (cur_speed)
  87   3                  // {
  88   3                  //     printf("ori speed %lu\n", cur_speed);
  89   3                  // }
  90   3              }
  91   2              else
  92   2              {
  93   3                  // 如果达到了重复检测的次数
  94   3                  speed_scan_cnt = 0;
  95   3                  cur_speed_average_val /= SPEED_SCAN_FILTER_CNT; // 时速取平均值
  96   3                  fun_info.speed = cur_speed_average_val;         // 存放得到的时速
  97   3                  cur_speed_average_val = 0;                      // 清空变量的值
  98   3                  
  99   3      #if USE_MY_DEBUG
              
                          if (fun_info.speed != 0)
                          {
                              printf("cur speed %lu km/h\n", fun_info.speed);
                          }
              
              #endif
 107   3      
 108   3                  // 限制要发送的时速:
 109   3                  if (fun_info.speed > 999)
 110   3                  {
 111   4                      fun_info.speed = 999;
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        05/20/2025 17:55:59 PAGE 3   

 112   4                  }
 113   3      
 114   3                  flag_get_speed = 1; //
 115   3              }
 116   2          }
 117   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    260    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     17       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
