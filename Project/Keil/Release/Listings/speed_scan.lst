C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        05/26/2025 16:52:38 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X
                    -000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Re
                    -lease\Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          // æ ‡å¿—ä½ï¼Œæ˜¯å¦ç”±æ›´æ–°è®¡æ•°,ç”±å®šæ—¶å™¨æ¥ç½®ä½
   4          // 0--æœªæ›´æ–°è„‰å†²è®¡æ•°ï¼Œ1--æœ‰æ–°çš„è„‰å†²è®¡æ•°
   5          volatile bit flag_is_update_speed_pulse_cnt = 0;
   6          volatile u16 speed_scan_time_cnt = 0;        // é€Ÿåº¦æ‰«ææ—¶ï¼Œç”¨åˆ°çš„æ—¶é—´è®¡æ•°å€¼ï¼Œä¼šåœ¨å®šæ—¶å
             -™¨ä¸­æ–­ä¸­ç´¯åŠ 
   7          volatile u16 speed_actual_scan_time_cnt = 0; // å­˜æ”¾å®é™…çš„é€Ÿåº¦æ‰«ææ—¶é—´(å®é™…çš„é€Ÿåº¦æ‰«æç”¨
             -æ—¶)
   8          // volatile u32 detect_speed_pulse_cnt = 0; // æ£€æµ‹æ—¶é€Ÿçš„è„‰å†²è®¡æ•°å€¼(ç”¨IOä¸­æ–­æ¥æ£€æµ‹)
   9          /*
  10              å­˜æ”¾ æ£€æµ‹åˆ°çš„æ—¶é€Ÿè„‰å†²è®¡æ•°å€¼ï¼Œä¼šåœ¨ä¸­æ–­å†…ç´¯åŠ 
  11              ä½¿ç”¨äº†åŒç¼“å†²ï¼Œ[0]ç”¨åœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­ï¼Œ[1]ç”¨åœ¨å¤„ç†å‡½æ•°ä¸­
  12              å½“ flag_is_update_speed_pulse_cnt == 1æ—¶ï¼Œè¯´æ˜å·²ç»æœ‰æ•°æ®æ›´æ–°
  13          */
  14          volatile u32 detect_speed_pulse_cnt[2] = {0}; // æ£€æµ‹æ—¶é€Ÿçš„è„‰å†²è®¡æ•°å€¼
  15          
  16          // æ—¶é€Ÿæ‰«æçš„é…ç½®
  17          void speed_scan_config(void)
  18          {
  19   1      #if 1 // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
  20   1          
  21   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x3); // è¾“å…¥æ¨¡å¼
  22   1          P1_PU |= GPIO_P15_PULL_UP(0x1);    // é…ç½®ä¸ºä¸Šæ‹‰
  23   1      
  24   1      #endif // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
  25   1      }
  26          
  27          // é€Ÿåº¦æ‰«æå‡½æ•°
  28          void speed_scan(void)
  29          {
  30   1          volatile u32 cur_speed = 0;                    // è®°å½•å½“å‰é‡‡é›†åˆ°çš„é€Ÿåº¦
  31   1          static volatile u32 cur_speed_average_val = 0; // å­˜æ”¾å½“å‰é€Ÿåº¦çš„å¹³å‡å€¼(å•ä½ï¼škm/h)
  32   1      
  33   1          static volatile u8 speed_scan_cnt = 0;
  34   1      
  35   1          if (flag_is_update_speed_pulse_cnt) // å¦‚æœæœ‰æ•°æ®æ›´æ–°
  36   1          {
  37   2              flag_is_update_speed_pulse_cnt = 0;
  38   2              /*
  39   2                  è®¡ç®— xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
  40   2                  xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° / è½¦è½®ä¸€åœˆå
             -¯¹åº”å¤šå°‘ä¸ªè„‰å†² * ä¸€åœˆå¯¹åº” xx æ¯«ç±³
  41   2                  æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
  42   2                  xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° * ä¸€åœˆå¯¹åº” 
             -xx æ¯«ç±³ / è½¦è½®ä¸€åœˆå¯¹åº”å¤šå°‘ä¸ªè„‰å†²
  43   2              */
  44   2              cur_speed = detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN;
  45   2      
  46   2              // printf("cur pulse cnt %lu \n", detect_speed_pulse_cnt[1]); // ä¸´æ—¶æµ‹è¯•ç”¨
  47   2      
  48   2              detect_speed_pulse_cnt[1] = 0; // æ¸…ç©ºè„‰å†²è®¡æ•°
  49   2              distance += cur_speed;         // å­˜æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        05/26/2025 16:52:38 PAGE 2   

  50   2      
  51   2              /*
  52   2                  å·²çŸ¥åœ¨æ‰«ææ—¶é—´å†…èµ°è¿‡äº†xx mm
  53   2                  æ—¶é€Ÿçš„è®¡ç®—å…¬å¼:
  54   2                  æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) * 3.6
  55   2                      æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000ï¼Œè½¬æ¢æˆ m/æ‰«ææ—¶é—´ çš„å•ä½
  56   2                      * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”)ï¼Œè½¬æ¢æˆä»¥sä¸ºå•ä½çš„é€Ÿåº¦
  57   2                      * 3.6ï¼Œå› ä¸º 1m/s == 3.6km/hï¼Œæœ€åè½¬æ¢æˆ ä»¥km/hçš„å•ä½
  58   2                  è½¬æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
  59   2                  æ—¶é€Ÿ == æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» * 36 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) / 10000ï¼›
  60   2      
  61   2                  é€æ¸å˜æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
  62   2                  cur_speed = cur_speed * 36 * (1 / (SPEED_SCAN_TIME_MS / 1000)) / 10000;
  63   2                  cur_speed = cur_speed * 36 * 1000 / SPEED_SCAN_TIME_MS / 10000;
  64   2                  cur_speed = cur_speed * 36 / SPEED_SCAN_TIME_MS / 10;
  65   2              */
  66   2              cur_speed = (cur_speed * 36) / speed_actual_scan_time_cnt / 10;
  67   2      
  68   2              // printf("cur speed %lu \n", cur_speed);
  69   2      
  70   2              if (speed_scan_cnt < SPEED_SCAN_FILTER_CNT)
  71   2              {
  72   3                  // å¦‚æœæœªè¾¾åˆ°é‡å¤æ£€æµ‹çš„æ¬¡æ•°
  73   3                  speed_scan_cnt++;
  74   3                  cur_speed_average_val += cur_speed; // ç´¯åŠ å½“å‰å¾—åˆ°çš„æ—¶é€Ÿ(å•ä½ï¼škm/h)
  75   3      
  76   3                  // if (cur_speed)
  77   3                  // {
  78   3                  //     printf("ori speed %lu\n", cur_speed);
  79   3                  // }
  80   3              }
  81   2              else
  82   2              {
  83   3                  // å¦‚æœè¾¾åˆ°äº†é‡å¤æ£€æµ‹çš„æ¬¡æ•°
  84   3                  speed_scan_cnt = 0;
  85   3                  cur_speed_average_val /= SPEED_SCAN_FILTER_CNT; // æ—¶é€Ÿå–å¹³å‡å€¼
  86   3                  fun_info.speed = cur_speed_average_val;         // å­˜æ”¾å¾—åˆ°çš„æ—¶é€Ÿ
  87   3                  cur_speed_average_val = 0;                      // æ¸…ç©ºå˜é‡çš„å€¼
  88   3                  
  89   3      
  90   3                  // printf("cur speed %lu km/h\n", fun_info.speed);
  91   3      #if USE_MY_DEBUG
              
                          if (fun_info.speed != 0)
                          {
                              printf("cur speed %lu km/h\n", fun_info.speed);
                          }
              
              #endif
  99   3      
 100   3                  // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
 101   3                  if (fun_info.speed > 999)
 102   3                  {
 103   4                      fun_info.speed = 999;
 104   4                  }
 105   3      
 106   3                  flag_get_speed = 1; //
 107   3              }
 108   2          }
 109   1      }


C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        05/26/2025 16:52:38 PAGE 3   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    247    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     17       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
