C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        06/10/2025 18:54:16 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X
                    -000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Re
                    -lease\Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          // æ ‡å¿—ä½ï¼Œæ˜¯å¦ç”±æ›´æ–°è®¡æ•°,ç”±å®šæ—¶å™¨æ¥ç½®ä½
   4          // 0--æœªæ›´æ–°è„‰å†²è®¡æ•°ï¼Œ1--æœ‰æ–°çš„è„‰å†²è®¡æ•°
   5          volatile bit flag_is_update_speed_pulse_cnt = 0;
   6          volatile u16 speed_scan_time_cnt = 0;        // é€Ÿåº¦æ‰«ææ—¶ï¼Œç”¨åˆ°çš„æ—¶é—´è®¡æ•°å€¼ï¼Œä¼šåœ¨å®šæ—¶å
             -™¨ä¸­æ–­ä¸­ç´¯åŠ 
   7          volatile u16 speed_actual_scan_time_cnt = 0; // å­˜æ”¾å®é™…çš„é€Ÿåº¦æ‰«ææ—¶é—´(å®é™…çš„é€Ÿåº¦æ‰«æç”¨
             -æ—¶)
   8          // volatile u32 detect_speed_pulse_cnt = 0; // æ£€æµ‹æ—¶é€Ÿçš„è„‰å†²è®¡æ•°å€¼(ç”¨IOä¸­æ–­æ¥æ£€æµ‹)
   9          /*
  10              å­˜æ”¾ æ£€æµ‹åˆ°çš„æ—¶é€Ÿè„‰å†²è®¡æ•°å€¼ï¼Œä¼šåœ¨ä¸­æ–­å†…ç´¯åŠ 
  11              ä½¿ç”¨äº†åŒç¼“å†²ï¼Œ[0]ç”¨åœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­ï¼Œ[1]ç”¨åœ¨å¤„ç†å‡½æ•°ä¸­
  12              å½“ flag_is_update_speed_pulse_cnt == 1æ—¶ï¼Œè¯´æ˜å·²ç»æœ‰æ•°æ®æ›´æ–°
  13          */
  14          volatile u32 detect_speed_pulse_cnt[2] = {0}; // æ£€æµ‹æ—¶é€Ÿçš„è„‰å†²è®¡æ•°å€¼
  15          
  16          // æ—¶é€Ÿæ‰«æçš„é…ç½®
  17          void speed_scan_config(void)
  18          {
  19   1      #if 1 // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
  20   1      
  21   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x3); // è¾“å…¥æ¨¡å¼
  22   1          P1_PU |= GPIO_P15_PULL_UP(0x1);    // é…ç½®ä¸ºä¸Šæ‹‰
  23   1      
  24   1      #endif // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
  25   1      }
  26          
  27          /*
  28              é‡‡ç”¨å®šæ—¶æ£€æµ‹è„‰å†²çš„æ–¹å¼æ¥æ£€æµ‹é€Ÿåº¦ï¼Œä½†æ˜¯æ¯æ®µæ—¶é—´å†…ä¼šå…ˆè®¡ç®—é€Ÿåº¦ï¼Œæœ€åå†
             -æ±‚å¹³å‡å€¼ï¼Œä¼šæœ‰1~2km/hçš„è¯¯å·®
  29          */
  30          #if 0 
              // é€Ÿåº¦æ‰«æå‡½æ•°
              void speed_scan(void)
              {
                  volatile u32 cur_speed = 0;                    // è®°å½•å½“å‰é‡‡é›†åˆ°çš„é€Ÿåº¦
                  static volatile u32 cur_speed_average_val = 0; // å­˜æ”¾å½“å‰é€Ÿåº¦çš„å¹³å‡å€¼(å•ä½ï¼škm/h)
                  static volatile u32 cur_speed_actual_scan_time_cnt = 0; // å­˜æ”¾å½“å‰ é€Ÿåº¦æ‰«ææ—¶é—´
              
                  static volatile u8 speed_scan_cnt = 0;
              
                  if (flag_is_update_speed_pulse_cnt) // å¦‚æœæœ‰æ•°æ®æ›´æ–°
                  {
                      flag_is_update_speed_pulse_cnt = 0;
                      /*
                          è®¡ç®— xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° / è½¦è½®ä¸€åœˆå
             -¯¹åº”å¤šå°‘ä¸ªè„‰å†² * ä¸€åœˆå¯¹åº” xx æ¯«ç±³
                          æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° * ä¸€åœˆå¯¹åº” 
             -xx æ¯«ç±³ / è½¦è½®ä¸€åœˆå¯¹åº”å¤šå°‘ä¸ªè„‰å†²
                      */
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        06/10/2025 18:54:16 PAGE 2   

                      cur_speed = detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN;
              
                      // printf("cur pulse cnt %lu \n", detect_speed_pulse_cnt[1]); // ä¸´æ—¶æµ‹è¯•ç”¨
              
                      detect_speed_pulse_cnt[1] = 0; // æ¸…ç©ºè„‰å†²è®¡æ•°
                      distance += cur_speed;         // å­˜æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³
              
                      /*
                          å·²çŸ¥åœ¨æ‰«ææ—¶é—´å†…èµ°è¿‡äº†xx mm
                          æ—¶é€Ÿçš„è®¡ç®—å…¬å¼:
                          æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) * 3.6
                              æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000ï¼Œè½¬æ¢æˆ m/æ‰«ææ—¶é—´ çš„å•ä½
                              * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”)ï¼Œè½¬æ¢æˆä»¥sä¸ºå•ä½çš„é€Ÿåº¦
                              * 3.6ï¼Œå› ä¸º 1m/s == 3.6km/hï¼Œæœ€åè½¬æ¢æˆ ä»¥km/hçš„å•ä½
                          è½¬æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          æ—¶é€Ÿ == æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» * 36 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) / 10000ï¼›
              
                          é€æ¸å˜æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          cur_speed = cur_speed * 36 * (1 / (SPEED_SCAN_TIME_MS / 1000)) / 10000;
                          cur_speed = cur_speed * 36 * 1000 / SPEED_SCAN_TIME_MS / 10000;
                          cur_speed = cur_speed * 36 / SPEED_SCAN_TIME_MS / 10;
                      */
                      // cur_speed = (cur_speed * 36) / speed_actual_scan_time_cnt / 10;
              
                      // printf("cur speed %lu \n", cur_speed);
              
                      if (speed_scan_cnt < SPEED_SCAN_FILTER_CNT)
                      {
                          // å¦‚æœæœªè¾¾åˆ°é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt++;
                          cur_speed_average_val += cur_speed ; // ç´¯åŠ å½“å‰å¾—åˆ°çš„æ—¶é€Ÿ(å•ä½ï¼škm/h)
                          cur_speed_actual_scan_time_cnt += speed_actual_scan_time_cnt ; // ç´¯åŠ å½“å‰
              
                          // if (cur_speed)
                          // {
                          //     printf("ori speed %lu\n", cur_speed);
                          // }
                      }
                      else
                      {
                          // å¦‚æœè¾¾åˆ°äº†é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt = 0;
                          cur_speed_average_val = (cur_speed_average_val * 36) / cur_speed_actual_scan_time_cnt / 10 ;
                          // cur_speed_average_val /= SPEED_SCAN_FILTER_CNT; // æ—¶é€Ÿå–å¹³å‡å€¼
                          fun_info.speed = cur_speed_average_val;         // å­˜æ”¾å¾—åˆ°çš„æ—¶é€Ÿ
                          cur_speed_average_val = 0;                      // æ¸…ç©ºå˜é‡çš„å€¼
                          cur_speed_actual_scan_time_cnt = 0;
                          
              
                          // printf("cur speed %lu km/h\n", fun_info.speed);
              #if USE_MY_DEBUG
              
                          if (fun_info.speed != 0)
                          {
                              printf("cur speed %lu km/h\n", fun_info.speed);
                          }
              
              #endif
              
                          // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
                          if (fun_info.speed > 999)
                          {
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        06/10/2025 18:54:16 PAGE 3   

                              fun_info.speed = 999;
                          }
              
                          flag_get_speed = 1; //
                      }
                  }
              }
              #endif
 119          
 120          #if 0
              // é€Ÿåº¦æ‰«æå‡½æ•°
              void speed_scan(void)
              {
                  volatile u32 cur_speed_pulse_cnt = 0;                   // è®°å½•å½“å‰é‡‡é›†åˆ°çš„é€Ÿåº¦
                  static volatile u32 cur_speed_average_val = 0;          // å­˜æ”¾å½“å‰é€Ÿåº¦çš„å¹³å‡å€¼(å•ä½ï¼škm/
             -h)
                  static volatile u32 cur_speed_actual_scan_time_cnt = 0; // å­˜æ”¾å½“å‰ é€Ÿåº¦æ‰«ææ—¶é—´
              
                  static volatile u8 speed_scan_cnt = 0;
              
                  if (flag_is_update_speed_pulse_cnt) // å¦‚æœæœ‰æ•°æ®æ›´æ–°
                  {
                      flag_is_update_speed_pulse_cnt = 0;
                      /*
                          è®¡ç®— xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° / è½¦è½®ä¸€åœˆå
             -¯¹åº”å¤šå°‘ä¸ªè„‰å†² * ä¸€åœˆå¯¹åº” xx æ¯«ç±³
                          æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          xx mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³ == å½“å‰æ‰«ææ—¶é—´å†…æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•° * ä¸€åœˆå¯¹åº” 
             -xx æ¯«ç±³ / è½¦è½®ä¸€åœˆå¯¹åº”å¤šå°‘ä¸ªè„‰å†²
                      */
                      // cur_speed_pulse_cnt = detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER
             -_TURN;
                      cur_speed_pulse_cnt = detect_speed_pulse_cnt[1]; // å¾—åˆ°ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°
              
                      distance += detect_speed_pulse_cnt[1] * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN; // å­˜
             -æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³
                      detect_speed_pulse_cnt[1] = 0;                                                              // æ¸…
             -ç©ºè„‰å†²è®¡æ•°
              
                      if (speed_scan_cnt < SPEED_SCAN_FILTER_CNT)
                      {
                          // å¦‚æœæœªè¾¾åˆ°é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt++;
                          cur_speed_average_val += cur_speed_pulse_cnt;                 // ç´¯åŠ å½“å‰å¾—åˆ°çš„è„‰å†²ä¸
             -ªæ•°
                          cur_speed_actual_scan_time_cnt += speed_actual_scan_time_cnt; // ç´¯åŠ å½“å‰æ‰«æé€Ÿåº¦æ‰€ç”
             -¨çš„æ—¶é—´
                      }
                      else
                      {
                          // å¦‚æœè¾¾åˆ°äº†é‡å¤æ£€æµ‹çš„æ¬¡æ•°
                          speed_scan_cnt = 0;
              
                          /*
                              å·²çŸ¥åœ¨æ‰«ææ—¶é—´å†…èµ°è¿‡äº†xx mm
                              æ—¶é€Ÿçš„è®¡ç®—å…¬å¼:
                              æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) * 3.6
                                  æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» / 1000ï¼Œè½¬æ¢æˆ m/æ‰«ææ—¶é—´ çš„å•ä½
                                  * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”)ï¼Œè½¬æ¢æˆä»¥sä¸ºå•ä½çš„é€Ÿåº¦
                                  * 3.6ï¼Œå› ä¸º 1m/s == 3.6km/hï¼Œæœ€åè½¬æ¢æˆ ä»¥km/hçš„å•ä½
                              è½¬æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        06/10/2025 18:54:16 PAGE 4   

                              æ—¶é€Ÿ == æ‰«ææ—¶é—´å†…èµ°è¿‡çš„è·ç¦» * 36 * (1 / æ‰«ææ—¶é—´å¯¹1sçš„å æ¯”) / 10000ï¼
             -›
              
                              é€æ¸å˜æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                          */
                          cur_speed_average_val = (cur_speed_average_val * 36 * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULS
             -E_PER_TURN) / 10 / cur_speed_actual_scan_time_cnt;
                          // cur_speed_average_val /= SPEED_SCAN_FILTER_CNT; // æ—¶é€Ÿå–å¹³å‡å€¼
                          fun_info.speed = cur_speed_average_val; // å­˜æ”¾å¾—åˆ°çš„æ—¶é€Ÿ
                          cur_speed_average_val = 0;              // æ¸…ç©ºå˜é‡çš„å€¼
                          cur_speed_actual_scan_time_cnt = 0;
              
                          printf("cur speed %lu km/h\n", fun_info.speed);
              #if USE_MY_DEBUG
              
                          if (fun_info.speed != 0)
                          {
                              printf("cur speed %lu km/h\n", fun_info.speed);
                          }
              
              #endif
              
                          // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
                          if (fun_info.speed > 999)
                          {
                              fun_info.speed = 999;
                          }
              
                          flag_get_speed = 1; //
                      }
                  }
              }
              #endif
 196          
 197          volatile bit flag_is_speed_scan_over_time; // é€Ÿåº¦æ£€æµ‹æ˜¯å¦ä¸€ç›´æ²¡æœ‰è„‰å†²åˆ°æ¥ï¼Œå¯¼è‡´è¶…æ—¶
 198          volatile u32 speed_pulse_cnt;
 199          volatile u32 speed_scan_time_ms;
 200          // static volatile u32 cur_speed_scan_time = 0;
 201          static volatile u32 cur_speed_scan_time = 0;
 202          static volatile u32 cur_speed_scan_pulse = 0;
 203          void update_speed_scan_data(void) // æ›´æ–°æ£€æµ‹æ—¶é€Ÿçš„æ•°æ®
 204          {
 205   1          cur_speed_scan_time += speed_scan_time_ms;
 206   1          speed_scan_time_ms = 0;
 207   1          cur_speed_scan_pulse += speed_pulse_cnt;
 208   1          speed_pulse_cnt = 0;
 209   1      }
 210          
 211          void update_cur_speed_scan_time(void)
 212          {
 213   1      
 214   1          // cur_speed_scan_time += speed_scan_time_ms;
 215   1          // // cur_speed_scan_time = 0;
 216   1          // cur_speed_scan_pulse = 0;
 217   1          // speed_scan_time_ms = 0;
 218   1      }
 219          
 220          void speed_scan(void)
 221          {
 222   1      
 223   1          volatile u32 cur_speed = 0;
 224   1      
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        06/10/2025 18:54:16 PAGE 5   

 225   1          if (cur_speed_scan_time >= 500 || flag_is_speed_scan_over_time)
 226   1          {
 227   2              if (flag_is_speed_scan_over_time) // è¶…æ—¶ï¼Œé‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°å¯¹åº”ä¸€ç›´æ˜¯0km/hï¼Œè®¤ä¸
             -ºæ—¶é€Ÿæ˜¯0
 228   2              {
 229   3                  cur_speed = 0;
 230   3              }
 231   2              else
 232   2              {
 233   3                  const u32 tmp = (cur_speed_scan_pulse * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN);
 234   3                  cur_speed = tmp / 10 / cur_speed_scan_time;
 235   3                  distance += tmp;
 236   3              }
 237   2      
 238   2              printf("cur speed %lu km/h\n", cur_speed);
 239   2              // printf("distance %lu m\n", distance / 100);
 240   2      
 241   2              cur_speed_scan_pulse = 0;
 242   2              cur_speed_scan_time = 0;
 243   2              flag_is_speed_scan_over_time = 0;
 244   2          }
 245   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    250    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =     28       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
