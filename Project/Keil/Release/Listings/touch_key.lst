C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         05/21/2025 18:01:24 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TOUCH_KEY
OBJECT MODULE PLACED IN .\Release\Objects\touch_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\touch_key.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) I
                    -NCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\L
                    -istings\touch_key.lst) OBJECT(.\Release\Objects\touch_key.obj)

line level    source

   1          #include "touch_key.h"
   2          
   3          /*
   4              æ ‡å¿—ä½ï¼Œè§¦æ‘¸æŒ‰é”®çš„æ‰«æå‘¨æœŸæ˜¯å¦åˆ°æ¥
   5              ç”±å®šæ—¶å™¨ä¸­æ–­ç½®ä½ï¼Œæ‰«æå‡½æ•°ä¸­åˆ¤æ–­è¯¥æ ‡å¿—ä½çš„çŠ¶æ€ï¼Œå†å†³å®šæ˜¯å¦è¦è¿›è¡ŒæŒ‰é”®
             -æ‰«æ
   6          */
   7          volatile bit flag_is_touch_key_scan_circle_arrived;
   8          
   9          /**
  10           * @brief __is_double_click() åˆ¤æ–­æ˜¯å¦æœ‰åŒå‡»åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®,å†…éƒ¨æœ€é•¿å»¶æ—¶æ—¶é—´ï¼šDETECT
             -_DOUBLE_CLICK_INTERVAL
  11           *
  12           * @param touch_key_id_const
  13           * @return u8 0--æ²¡æœ‰åŒå‡»åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®ï¼Œ1--åŒå‡»äº†åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®
  14           */
  15          u8 __is_double_click(const u32 touch_key_id_const)
  16          {
  17   1          u8 i = 0;                   // å¾ªç¯è®¡æ•°å€¼
  18   1          volatile u32 touch_key = 0; // å­˜æ”¾æ¯æ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®
  19   1      
  20   1          for (; i < DETECT_DOUBLE_CLICK_INTERVAL; i++)
  21   1          {
  22   2              delay_ms(1);
  23   2              __tk_scan();
  24   2              touch_key = __tk_key_flag;
  25   2      
  26   2              if (touch_key_id_const == touch_key)
  27   2              {
  28   3                  // å¦‚æœæ£€æµ‹åˆ°æ˜¯åŒä¸€ä¸ªæŒ‰é”®æŒ‰ä¸‹ï¼Œè¯´æ˜æ˜¯åŒå‡»
  29   3                  return 1; // åŒå‡»äº†åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®ï¼Œè¿”å›1
  30   3              }
  31   2          }
  32   1      
  33   1          return 0; // æ²¡æœ‰åŒå‡»åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®ï¼Œè¿”å›0
  34   1      }
  35          
  36          // ä½¿ç”¨touch_keyä¹‹å‰ï¼Œå…ˆè°ƒç”¨å®˜æ–¹æä¾›çš„è§¦æ‘¸æ¨¡å—çš„åˆå§‹åŒ–å‡½æ•° tk_param_init();
  37          void touch_key_scan(void)
  38          {
  39   1      
  40   1      #if 1
  41   1          // static volatile u8 filter_cnt = 0; // æŒ‰é”®æ¶ˆæŠ–ä½¿ç”¨åˆ°çš„å˜é‡
  42   1          volatile u32 touch_key = 0;                   // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
  43   1          static volatile u32 touch_key_last = 0;                // ç”¨äºå­˜æ”¾é•¿æŒ‰æ—¶ï¼Œå¯¹åº”çš„æŒ‰é”®
  44   1          static volatile u32 touch_time_cnt = 0;       // é•¿æŒ‰è®¡æ•°å€¼
  45   1          static volatile u8 touch_key_scan_status = 0; // éé˜»å¡çš„æŒ‰é”®æ‰«æå‡½æ•°ä¸­ï¼Œä½¿ç”¨çš„çŠ¶æ€æœ
             -º
  46   1      
  47   1          if (0 == flag_is_touch_key_scan_circle_arrived)
  48   1          {
  49   2              // å¦‚æœæ‰«æå‘¨æœŸæ²¡æœ‰åˆ°æ¥ï¼Œä¸æ‰§è¡ŒæŒ‰é”®æ‰«æ
  50   2              return;
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         05/21/2025 18:01:24 PAGE 2   

  51   2          }
  52   1      
  53   1          flag_is_touch_key_scan_circle_arrived = 0;
  54   1      
  55   1          WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
  56   1          /* æŒ‰é”®æ‰«æå‡½æ•° */
  57   1          __tk_scan();                 // ä½¿ç”¨äº†åº“é‡Œé¢çš„æ¥å£ï¼ˆé—­æºåº“ï¼‰
  58   1          WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
  59   1          touch_key = __tk_key_flag;   // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
  60   1      
  61   1          if (TOUCH_KEY_SCAN_STATUS_NONE == touch_key_scan_status) // æœªæ£€æµ‹åˆ°æŒ‰é”®æ—¶
  62   1          {
  63   2              // å¦‚æœæœ‰æŒ‰é”®æŒ‰ä¸‹ï¼ˆå¹¶ä¸”ä¹‹å‰æ‰«æåˆ°çš„ä¸æ˜¯é•¿æŒ‰ï¼‰
  64   2      
  65   2              // åˆ¤æ–­æ˜¯å¦ä¸ºé•¿æŒ‰ï¼š
  66   2      
  67   2              if (touch_key_last == 0) // å¦‚æœä¹‹å‰æœªæ£€æµ‹åˆ°æŒ‰é”®
  68   2              {
  69   3                  touch_key_last = touch_key;
  70   3              }
  71   2              else if (touch_key_last == touch_key)
  72   2              {
  73   3                  // å¦‚æœä¸Šæ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸æ­¤æ¬¡çš„æŒ‰é”®ç›¸ç­‰ï¼Œè¯´æ˜æŒ‰é”®è¿˜æœªæ¾å¼€
  74   3                  touch_time_cnt += (TOUCH_KEY_SCAN_CIRCLE_TIMES);
  75   3      
  76   3                  if (touch_time_cnt >= LONG_PRESS_TIME_THRESHOLD_MS)
  77   3                  {
  78   4                      // å¦‚æœé•¿æŒ‰è¶…è¿‡äº†è®¾ç½®çš„é•¿æŒ‰æ—¶é—´
  79   4                      // è·³è½¬åˆ°é•¿æŒ‰å¤„ç†
  80   4                      touch_time_cnt = 0; // æ¸…é™¤é•¿æŒ‰æ—¶é—´è®¡æ•°
  81   4                      // printf("long press\n");
  82   4                      touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_HANDLE_LONG_PRESS;
  83   4                  }
  84   3              }
  85   2              else
  86   2              {
  87   3                  // å¦‚æœä¸Šæ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸æ­¤æ¬¡çš„æŒ‰é”®ä¸ç›¸ç­‰ï¼Œå¹¶ä¸”ä¸Šæ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®ä
             -¸ç­‰äº0
  88   3                  // touch_time_cnt = 0; // æ¸…é™¤é•¿æŒ‰æ—¶é—´è®¡æ•°ï¼ˆå¯ä»¥ç•™åˆ°æ”¶å°¾å¤„ç†ï¼‰
  89   3      
  90   3                  // è·³è½¬åˆ°çŸ­æŒ‰å¤„ç†
  91   3                  touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_HANDLE_SHORT_PRESS;
  92   3      
  93   3                  // printf("short press\n");
  94   3              }
  95   2      
  96   2              // delay_ms(1); //
  97   2          }
  98   1      
  99   1          if (TOUCH_KEY_SCAN_STATUS_IS_HANDLE_SHORT_PRESS == touch_key_scan_status)
 100   1          {
 101   2              // å¦‚æœæ˜¯æ­£åœ¨å¤„ç†çŸ­æŒ‰
 102   2              bit flag_is_double_click = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦æœ‰æŒ‰é”®åŒå‡»
 103   2      
 104   2              if (TOUCH_KEY_ID_1 == touch_key_last)
 105   2              {
 106   3                  // å¦‚æœKEY1è¢«è§¦æ‘¸
 107   3                  flag_is_double_click = __is_double_click(touch_key_last);
 108   3                  if (flag_is_double_click)
 109   3                  {
 110   4                      // å¦‚æœæœ‰æŒ‰é”®åŒå‡»
 111   4                      printf("k1 double press\n");
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         05/21/2025 18:01:24 PAGE 3   

 112   4      #if USE_MY_DEBUG
                              printf("k1 double press\n");
              #endif
 115   4                      // send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY1); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€¼
 116   4                  }
 117   3                  else
 118   3                  {
 119   4                      // å¦‚æœæ²¡æœ‰æŒ‰é”®åŒå‡»ï¼Œè¯´æ˜æ˜¯çŸ­æŒ‰
 120   4                      printf("k1 press\n");
 121   4      #if USE_MY_DEBUG
                              printf("k1 press\n");
              #endif
 124   4                      // send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY1); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€¼
 125   4                  }
 126   3      
 127   3                  touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE; // ç­‰å¾…æŒ‰é”®æ¾å
             -¼€
 128   3              }
 129   2              else if (TOUCH_KEY_ID_2 == touch_key_last)
 130   2              {
 131   3                  // å¦‚æœKEY2è¢«è§¦æ‘¸
 132   3                  flag_is_double_click = __is_double_click(touch_key_last);
 133   3                  if (flag_is_double_click)
 134   3                  {
 135   4                      // å¦‚æœæœ‰æŒ‰é”®åŒå‡»
 136   4                      printf("k2 double press\n");
 137   4      #if USE_MY_DEBUG
                              printf("k2 double press\n");
              #endif
 140   4                      // send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY2); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€¼
 141   4                  }
 142   3                  else
 143   3                  {
 144   4                      // å¦‚æœæ²¡æœ‰æŒ‰é”®åŒå‡»ï¼Œè¯´æ˜æ˜¯çŸ­æŒ‰
 145   4                      printf("k2 press\n");
 146   4      #if USE_MY_DEBUG
                              printf("k2 press\n");
              #endif
 149   4                      // send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY2); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€¼
 150   4                  }
 151   3      
 152   3                  touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE; // ç­‰å¾…æŒ‰é”®æ¾å
             -¼€
 153   3              }
 154   2          }
 155   1      
 156   1          if (TOUCH_KEY_SCAN_STATUS_IS_HANDLE_LONG_PRESS == touch_key_scan_status)
 157   1          {
 158   2              // å¤„ç†é•¿æŒ‰
 159   2              if (TOUCH_KEY_ID_1 == touch_key)
 160   2              {
 161   3                  // å¦‚æœKEY1è¢«è§¦æ‘¸
 162   3                  printf("k1 long press\n");
 163   3      #if USE_MY_DEBUG
                          printf("k1 long press\n");
              #endif
 166   3                  // send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY1);
 167   3              }
 168   2              else if (TOUCH_KEY_ID_2 == touch_key)
 169   2              {
 170   3                  // å¦‚æœKEY2è¢«è§¦æ‘¸
 171   3                  printf("k2 long press\n");
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         05/21/2025 18:01:24 PAGE 4   

 172   3      #if USE_MY_DEBUG
                          printf("k2 long press\n");
              #endif
 175   3                  // send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY2);
 176   3              }
 177   2      
 178   2              touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_HANDLE_HOLD_PRESS; // è·³è½¬åˆ°é•¿æŒ‰æŒç»­
 179   2          }
 180   1      
 181   1          if (TOUCH_KEY_SCAN_STATUS_IS_HANDLE_HOLD_PRESS == touch_key_scan_status)
 182   1          {
 183   2              // å¤„ç†é•¿æŒ‰æŒç»­
 184   2      
 185   2              if (touch_key_last == touch_key)
 186   2              {
 187   3                  touch_time_cnt += TOUCH_KEY_SCAN_CIRCLE_TIMES;
 188   3                  if (TOUCH_KEY_ID_1 == touch_key)
 189   3                  {
 190   4                      if (touch_time_cnt >= HOLD_PRESS_TIME_THRESHOLD_MS)
 191   4                      {
 192   5                          touch_time_cnt = 0;
 193   5                          printf("k1 continue press\n");
 194   5      #if USE_MY_DEBUG
                                  printf("k1 continue press\n");
              #endif
 197   5                          // send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY1);
 198   5                      }
 199   4                  }
 200   3                  else if (TOUCH_KEY_ID_2 == touch_key)
 201   3                  {
 202   4                      if (touch_time_cnt >= HOLD_PRESS_TIME_THRESHOLD_MS)
 203   4                      {
 204   5                          touch_time_cnt = 0;
 205   5                          printf("k2 continue press\n");
 206   5      #if USE_MY_DEBUG
                                  printf("k2 continue press\n");
              #endif
 209   5                          // send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY2);
 210   5                      }
 211   4                  }
 212   3      
 213   3                  // delay_ms(1);
 214   3              }
 215   2              else
 216   2              {
 217   3                  // å¦‚æœä¹‹å‰æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸å½“å‰æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸ä¸€è‡´ï¼Œ
 218   3                  // è¯´æ˜ å¯èƒ½æ¾å¼€äº†æ‰‹ æˆ–æ˜¯ ä¸€åªæ‰‹æŒ‰ä½äº†åŸæ¥çš„æŒ‰é”®å¦ä¸€åªæ‰‹æŒ‰äº†å…¶ä»–æ
             -Œ‰é”®
 219   3      
 220   3                  // è·³è½¬åˆ°ç­‰å¾…é•¿æŒ‰æ¾å¼€
 221   3                  touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE;
 222   3              }
 223   2          }
 224   1      
 225   1          if ((TOUCH_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE == touch_key_scan_status) ||
 226   1              (TOUCH_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE == touch_key_scan_status))
 227   1          {
 228   2              // å¦‚æœæ˜¯ç­‰å¾…æŒ‰é”®æ¾å¼€
 229   2              static volatile u16 loose_cnt = 0; // å­˜æ”¾æ¾æ‰‹è®¡æ•°å€¼
 230   2      
 231   2              if (touch_key == 0)
 232   2              {
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         05/21/2025 18:01:24 PAGE 5   

 233   3                  loose_cnt += TOUCH_KEY_SCAN_CIRCLE_TIMES;
 234   3                  delay_ms(1);
 235   3              }
 236   2              else
 237   2              {
 238   3                  // åªè¦æœ‰ä¸€æ¬¡æ£€æµ‹åˆ°æŒ‰é”®ï¼Œè¯´æ˜æ²¡æœ‰æ¾å¼€æ‰‹
 239   3                  loose_cnt = 0;
 240   3              }
 241   2      
 242   2              if (loose_cnt >= LOOSE_PRESS_CNT_MS) // è¿™é‡Œçš„æ¯”è¾ƒå€¼éœ€è¦æ³¨æ„ï¼Œä¸èƒ½å¤§äºå˜é‡ç±»å‹å
             -¯¹åº”çš„æœ€å¤§å€¼
 243   2              {
 244   3                  loose_cnt = 0; // æ¸…ç©ºæ¾æ‰‹è®¡æ•°
 245   3                  // å¦‚æœ xx mså†…æ²¡æœ‰æ£€æµ‹åˆ°æŒ‰é”®æŒ‰ä¸‹ï¼Œè¯´æ˜å·²ç»æ¾å¼€æ‰‹
 246   3      
 247   3                  if (TOUCH_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE == touch_key_scan_status)
 248   3                  {
 249   4                      if (TOUCH_KEY_ID_1 == touch_key_last)
 250   4                      {
 251   5                          printf("k1 long press loose\n");
 252   5      #if USE_MY_DEBUG
                                  printf("k1 long press loose\n");
              #endif
 255   5                          // send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY1);
 256   5                      }
 257   4                      else if (TOUCH_KEY_ID_2 == touch_key_last)
 258   4                      {
 259   5                          printf("k2 long press loose\n");
 260   5      #if USE_MY_DEBUG
                                  printf("k2 long press loose\n");
              #endif
 263   5                          // send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY2);
 264   5                      }
 265   4                  }
 266   3      
 267   3                  touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_END; // è·³è½¬åˆ°æ”¶å°¾å¤„ç†
 268   3              }
 269   2          }
 270   1      
 271   1          if (TOUCH_KEY_SCAN_STATUS_IS_END == touch_key_scan_status)
 272   1          {
 273   2              // æ”¶å°¾å¤„ç†
 274   2              touch_key = 0;
 275   2              touch_key_last = 0;
 276   2              touch_time_cnt = 0;
 277   2      
 278   2              touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_NONE;
 279   2          }
 280   1      #endif
 281   1      }
 282          
 283          // void touch_key_handle(void)
 284          // {
 285          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    654    ----
   CONSTANT SIZE    =    164    ----
   XDATA SIZE       =     11      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         05/21/2025 18:01:24 PAGE 6   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
