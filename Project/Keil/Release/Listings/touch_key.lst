C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         06/03/2025 17:12:24 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TOUCH_KEY
OBJECT MODULE PLACED IN .\Release\Objects\touch_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\touch_key.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X0
                    -00C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Rel
                    -ease\Listings\touch_key.lst) OBJECT(.\Release\Objects\touch_key.obj)

line level    source

   1          #include "touch_key.h"
   2          
   3          /*
   4              æ ‡å¿—ä½ï¼Œè§¦æ‘¸æŒ‰é”®çš„æ‰«æå‘¨æœŸæ˜¯å¦åˆ°æ¥
   5              ç”±å®šæ—¶å™¨ä¸­æ–­ç½®ä½ï¼Œæ‰«æå‡½æ•°ä¸­åˆ¤æ–­è¯¥æ ‡å¿—ä½çš„çŠ¶æ€ï¼Œå†å†³å®šæ˜¯å¦è¦è¿›è¡ŒæŒ‰é”®
             -æ‰«æ
   6          */
   7          // volatile bit flag_is_touch_key_scan_circle_arrived;
   8          
   9          // å®šä¹‰è§¦æ‘¸æŒ‰é”®çš„æŒ‰é”®äº‹ä»¶
  10          enum TOUCH_KEY_EVENT
  11          {
  12              TOUCH_KEY_EVENT_NONE = 0,
  13              TOUCH_KEY_EVENT_ID_1_CLICK,
  14              TOUCH_KEY_EVENT_ID_1_DOUBLE,
  15              TOUCH_KEY_EVENT_ID_1_LONG,
  16              TOUCH_KEY_EVENT_ID_1_HOLD,
  17              TOUCH_KEY_EVENT_ID_1_LOOSE,
  18          
  19              TOUCH_KEY_EVENT_ID_2_CLICK,
  20              TOUCH_KEY_EVENT_ID_2_DOUBLE,
  21              TOUCH_KEY_EVENT_ID_2_LONG,
  22              TOUCH_KEY_EVENT_ID_2_HOLD,
  23              TOUCH_KEY_EVENT_ID_2_LOOSE,
  24          };
  25          
  26          #define TOUCH_KEY_EFFECT_EVENT_NUMS (5) // å•ä¸ªè§¦æ‘¸æŒ‰é”®çš„æœ‰æ•ˆæŒ‰é”®äº‹ä»¶ä¸ªæ•°
  27          // å°†æŒ‰é”®idå’ŒæŒ‰é”®äº‹ä»¶ç»‘å®šèµ·æ¥ï¼Œåœ¨ xx å‡½æ•°ä¸­ï¼Œé€šè¿‡æŸ¥è¡¨çš„æ–¹å¼å¾—åˆ°æŒ‰é”®äº‹ä»¶
  28          static const u8 touch_key_event_table[][TOUCH_KEY_EFFECT_EVENT_NUMS + 1] = {
  29              // [0]--æŒ‰é”®å¯¹åº”çš„idå·ï¼Œç”¨äºæŸ¥è¡¨ï¼Œ[1]ã€[2]ã€[3]...--ç”¨äºä¸ key_driver.h ä¸­å®šä¹‰çš„æ
             -Œ‰é”®äº‹ä»¶KEY_EVENTç»‘å®šå…³ç³»(ä¸€å®šè¦ä¸€ä¸€å¯¹åº”)
  30              {TOUCH_KEY_ID_1, TOUCH_KEY_EVENT_ID_1_CLICK, TOUCH_KEY_EVENT_ID_1_DOUBLE, TOUCH_KEY_EVENT_ID_1_LONG, T
             -OUCH_KEY_EVENT_ID_1_HOLD, TOUCH_KEY_EVENT_ID_1_LOOSE}, //
  31              {TOUCH_KEY_ID_2, TOUCH_KEY_EVENT_ID_2_CLICK, TOUCH_KEY_EVENT_ID_2_DOUBLE, TOUCH_KEY_EVENT_ID_2_LONG, T
             -OUCH_KEY_EVENT_ID_2_HOLD, TOUCH_KEY_EVENT_ID_2_LOOSE}, //
  32          };
  33          
  34          extern u8 touch_key_get_key_id(void);
  35          volatile struct key_driver_para touch_key_para = {
  36              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™ï¼š
  37              // .scan_times = 10,   // æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
  38              // .last_key = NO_KEY, // ä¸Šä¸€æ¬¡å¾—åˆ°çš„æŒ‰é”®é”®å€¼ï¼Œåˆå§‹åŒ–ä¸ºæ— æ•ˆçš„é”®å€¼
  39              // // .filter_value = NO_KEY, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´å¾—åˆ°çš„é”®å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨
             -)ï¼Œåˆå§‹åŒ–ä¸º NO_KEY
  40              // // .filter_cnt = 0, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´çš„ç´¯åŠ å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨)ï¼Œåˆå§‹
             -åŒ–ä¸º0
  41              // .filter_time = 3,       // æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  42              // .long_time = 50,        // åˆ¤å®šæŒ‰é”®æ˜¯é•¿æŒ‰å¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  43              // .hold_time = (75 + 15), // åˆ¤å®šæŒ‰é”®æ˜¯HOLDå¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  44              // // .press_cnt = 0, // ä¸long_timeå’Œhold_timeå¯¹æ¯”, åˆ¤æ–­é•¿æŒ‰äº‹ä»¶å’ŒHOLDäº‹ä»¶
  45              // // .click_cnt = 0,
  46              // .click_delay_time = 20, // æŒ‰é”®æŠ¬èµ·åï¼Œç­‰å¾…è¿å‡»çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
  47              // // .notify_value = 0,
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         06/03/2025 17:12:24 PAGE 2   

  48              // .key_type = KEY_TYPE_AD, // æŒ‰é”®ç±»å‹ä¸ºadæŒ‰é”®
  49              // .get_value = ad_key_get_key_id,
  50          
  51              // .latest_key_val = AD_KEY_ID_NONE,
  52              // .latest_key_event = KEY_EVENT_NONE,
  53          
  54              TOUCH_KEY_SCAN_CIRCLE_TIMES,
  55              0,
  56              // NO_KEY,
  57              0,
  58          
  59              0,
  60              0,
  61              3,
  62          
  63              LONG_PRESS_TIME_THRESHOLD_MS / TOUCH_KEY_SCAN_CIRCLE_TIMES,
  64              (LONG_PRESS_TIME_THRESHOLD_MS + HOLD_PRESS_TIME_THRESHOLD_MS) / TOUCH_KEY_SCAN_CIRCLE_TIMES,
  65              0,
  66          
  67              0,
  68              0,
  69              200 / TOUCH_KEY_SCAN_CIRCLE_TIMES,
  70              // NO_KEY,
  71              0,
  72              KEY_TYPE_TOUCH,
  73              touch_key_get_key_id,
  74          
  75              TOUCH_KEY_ID_NONE,
  76              KEY_EVENT_NONE,
  77          };
  78          
  79          static u8 touch_key_get_key_id(void)
  80          {
  81   1          WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
  82   1          /* æŒ‰é”®æ‰«æå‡½æ•° */
  83   1          __tk_scan(); // ä½¿ç”¨äº†åº“é‡Œé¢çš„æ¥å£ï¼ˆé—­æºåº“ï¼‰
  84   1          WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
  85   1          // delay_ms(1); // å»¶æ—¶å¹¶ä¸èƒ½è§£å†³åˆšä¸Šç‚¹å°±æ£€æµ‹åˆ°é•¿æŒ‰çš„é—®é¢˜
  86   1      
  87   1          // printf("touch key scan\n");
  88   1      
  89   1          if (TK_CH9_VALIB == __tk_key_flag)
  90   1          {
  91   2              return TOUCH_KEY_ID_1;
  92   2          }
  93   1          else if (TK_CH10_VALIB == __tk_key_flag)
  94   1          {
  95   2              return TOUCH_KEY_ID_2;
  96   2          }
  97   1          else
  98   1          {
  99   2              // return TOUCH_KEY_ID_NONE;
 100   2              return NO_KEY;
 101   2          }
 102   1      
 103   1          // return __tk_key_flag;        // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
 104   1      }
 105          
 106          /**
 107           * @brief å°†æŒ‰é”®å€¼å’Œkey_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
 108           *
 109           * @param key_val è§¦æ‘¸æŒ‰é”®é”®å€¼
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         06/03/2025 17:12:24 PAGE 3   

 110           * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
 111           * @return u8 åœ¨touch_key_event_tableä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› TOUCH_KEY_
             -EVENT_NONE
 112           */
 113          static u8 __touch_key_get_event(const u8 key_val, const u8 key_event)
 114          {
 115   1          volatile u8 ret_key_event = TOUCH_KEY_EVENT_NONE;
 116   1          u8 i = 0;
 117   1          for (; i < ARRAY_SIZE(touch_key_event_table); i++)
 118   1          {
 119   2              // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•ˆï¼Œ
             -éœ€è¦æ‰‹åŠ¨ä¿®æ”¹
 120   2              if (key_val == touch_key_event_table[i][0])
 121   2              {
 122   3                  ret_key_event = touch_key_event_table[i][key_event];
 123   3                  break;
 124   3              }
 125   2          }
 126   1      
 127   1          return ret_key_event;
 128   1      }
 129          
 130          void touch_key_handle(void)
 131          {
 132   1          u8 touch_key_event = TOUCH_KEY_EVENT_NONE;
 133   1      
 134   1          if (touch_key_para.latest_key_val == TOUCH_KEY_ID_NONE)
 135   1          {
 136   2              return;
 137   2          }
 138   1      
 139   1          touch_key_event = __touch_key_get_event(touch_key_para.latest_key_val, touch_key_para.latest_key_event
             -);
 140   1          touch_key_para.latest_key_val = TOUCH_KEY_ID_NONE;
 141   1          touch_key_para.latest_key_event = KEY_EVENT_NONE;
 142   1      
 143   1          switch (touch_key_event)
 144   1          {
 145   2          case TOUCH_KEY_EVENT_ID_1_CLICK:
 146   2              // printf("touch key 1 click\n");
 147   2              break;
 148   2      
 149   2          case TOUCH_KEY_EVENT_ID_1_DOUBLE:
 150   2              // printf("touch key 1 double\n");
 151   2              break;
 152   2      
 153   2          case TOUCH_KEY_EVENT_ID_1_LONG:
 154   2              // printf("touch key 1 long\n");
 155   2              break;
 156   2      
 157   2          case TOUCH_KEY_EVENT_ID_1_HOLD:
 158   2              // printf("touch key 1 hold\n");
 159   2              break;
 160   2      
 161   2          case TOUCH_KEY_EVENT_ID_1_LOOSE:
 162   2              // printf("touch key 1 loose\n");
 163   2              break;
 164   2          case TOUCH_KEY_EVENT_ID_2_CLICK:
 165   2              // printf("touch key 2 click\n");
 166   2              break;
 167   2      
 168   2          case TOUCH_KEY_EVENT_ID_2_DOUBLE:
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         06/03/2025 17:12:24 PAGE 4   

 169   2              // printf("touch key 2 double\n");
 170   2              break;
 171   2      
 172   2          case TOUCH_KEY_EVENT_ID_2_LONG:
 173   2              // printf("touch key 2 long\n");
 174   2              break;
 175   2      
 176   2          case TOUCH_KEY_EVENT_ID_2_HOLD:
 177   2              // printf("touch key 2 hold\n");
 178   2              break;
 179   2      
 180   2          case TOUCH_KEY_EVENT_ID_2_LOOSE:
 181   2              // printf("touch key 2 loose\n");
 182   2              break;
 183   2      
 184   2          default:
 185   2              break;
 186   2          }
 187   1      }
 188          
 189          /**
 190           * @brief __is_double_click() åˆ¤æ–­æ˜¯å¦æœ‰åŒå‡»åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®,å†…éƒ¨æœ€é•¿å»¶æ—¶æ—¶é—´ï¼šDETECT
             -_DOUBLE_CLICK_INTERVAL
 191           *
 192           * @param touch_key_id_const
 193           * @return u8 0--æ²¡æœ‰åŒå‡»åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®ï¼Œ1--åŒå‡»äº†åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®
 194           */
 195          // u8 __is_double_click(const u32 touch_key_id_const)
 196          // {
 197          //     u8 i = 0;                   // å¾ªç¯è®¡æ•°å€¼
 198          //     volatile u32 touch_key = 0; // å­˜æ”¾æ¯æ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®
 199          
 200          //     for (; i < DETECT_DOUBLE_CLICK_INTERVAL; i++)
 201          //     {
 202          //         delay_ms(1);
 203          //         __tk_scan();
 204          //         touch_key = __tk_key_flag;
 205          
 206          //         if (touch_key_id_const == touch_key)
 207          //         {
 208          //             // å¦‚æœæ£€æµ‹åˆ°æ˜¯åŒä¸€ä¸ªæŒ‰é”®æŒ‰ä¸‹ï¼Œè¯´æ˜æ˜¯åŒå‡»
 209          //             return 1; // åŒå‡»äº†åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®ï¼Œè¿”å›1
 210          //         }
 211          //     }
 212          
 213          //     return 0; // æ²¡æœ‰åŒå‡»åŒä¸€ä¸ªè§¦æ‘¸æŒ‰é”®ï¼Œè¿”å›0
 214          // }
 215          
 216          // ä½¿ç”¨touch_keyä¹‹å‰ï¼Œå…ˆè°ƒç”¨å®˜æ–¹æä¾›çš„è§¦æ‘¸æ¨¡å—çš„åˆå§‹åŒ–å‡½æ•° tk_param_init();
 217          // void touch_key_scan(void)
 218          // {
 219          
 220          // #if 0
 221          //     // static volatile u8 filter_cnt = 0; // æŒ‰é”®æ¶ˆæŠ–ä½¿ç”¨åˆ°çš„å˜é‡
 222          //     volatile u32 touch_key = 0;                   // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
 223          //     static volatile u32 touch_key_last = 0;                // ç”¨äºå­˜æ”¾é•¿æŒ‰æ—¶ï¼Œå¯¹åº”çš„æŒ‰é”®
 224          //     static volatile u32 touch_time_cnt = 0;       // é•¿æŒ‰è®¡æ•°å€¼
 225          //     static volatile u8 touch_key_scan_status = 0; // éé˜»å¡çš„æŒ‰é”®æ‰«æå‡½æ•°ä¸­ï¼Œä½¿ç”¨çš„çŠ¶æ€
             -æœº
 226          
 227          //     if (0 == flag_is_touch_key_scan_circle_arrived)
 228          //     {
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         06/03/2025 17:12:24 PAGE 5   

 229          //         // å¦‚æœæ‰«æå‘¨æœŸæ²¡æœ‰åˆ°æ¥ï¼Œä¸æ‰§è¡ŒæŒ‰é”®æ‰«æ
 230          //         return;
 231          //     }
 232          
 233          //     flag_is_touch_key_scan_circle_arrived = 0;
 234          
 235          //     WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
 236          //     /* æŒ‰é”®æ‰«æå‡½æ•° */
 237          //     __tk_scan();                 // ä½¿ç”¨äº†åº“é‡Œé¢çš„æ¥å£ï¼ˆé—­æºåº“ï¼‰
 238          //     WDT_KEY = WDT_KEY_VAL(0xAA); // å–‚ç‹—å¹¶æ¸…é™¤ wdt_pending
 239          //     touch_key = __tk_key_flag;   // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
 240          
 241          //     if (TOUCH_KEY_SCAN_STATUS_NONE == touch_key_scan_status) // æœªæ£€æµ‹åˆ°æŒ‰é”®æ—¶
 242          //     {
 243          //         // å¦‚æœæœ‰æŒ‰é”®æŒ‰ä¸‹ï¼ˆå¹¶ä¸”ä¹‹å‰æ‰«æåˆ°çš„ä¸æ˜¯é•¿æŒ‰ï¼‰
 244          
 245          //         // åˆ¤æ–­æ˜¯å¦ä¸ºé•¿æŒ‰ï¼š
 246          
 247          //         if (touch_key_last == 0) // å¦‚æœä¹‹å‰æœªæ£€æµ‹åˆ°æŒ‰é”®
 248          //         {
 249          //             touch_key_last = touch_key;
 250          //         }
 251          //         else if (touch_key_last == touch_key)
 252          //         {
 253          //             // å¦‚æœä¸Šæ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸æ­¤æ¬¡çš„æŒ‰é”®ç›¸ç­‰ï¼Œè¯´æ˜æŒ‰é”®è¿˜æœªæ¾å¼€
 254          //             touch_time_cnt += (TOUCH_KEY_SCAN_CIRCLE_TIMES);
 255          
 256          //             if (touch_time_cnt >= LONG_PRESS_TIME_THRESHOLD_MS)
 257          //             {
 258          //                 // å¦‚æœé•¿æŒ‰è¶…è¿‡äº†è®¾ç½®çš„é•¿æŒ‰æ—¶é—´
 259          //                 // è·³è½¬åˆ°é•¿æŒ‰å¤„ç†
 260          //                 touch_time_cnt = 0; // æ¸…é™¤é•¿æŒ‰æ—¶é—´è®¡æ•°
 261          //                 // printf("long press\n");
 262          //                 touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_HANDLE_LONG_PRESS;
 263          //             }
 264          //         }
 265          //         else
 266          //         {
 267          //             // å¦‚æœä¸Šæ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸æ­¤æ¬¡çš„æŒ‰é”®ä¸ç›¸ç­‰ï¼Œå¹¶ä¸”ä¸Šæ¬¡æ£€æµ‹åˆ°çš„æŒ‰é
             -”®ä¸ç­‰äº0
 268          //             // touch_time_cnt = 0; // æ¸…é™¤é•¿æŒ‰æ—¶é—´è®¡æ•°ï¼ˆå¯ä»¥ç•™åˆ°æ”¶å°¾å¤„ç†ï¼‰
 269          
 270          //             // è·³è½¬åˆ°çŸ­æŒ‰å¤„ç†
 271          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_HANDLE_SHORT_PRESS;
 272          
 273          //             // printf("short press\n");
 274          //         }
 275          
 276          //         // delay_ms(1); //
 277          //     }
 278          
 279          //     if (TOUCH_KEY_SCAN_STATUS_IS_HANDLE_SHORT_PRESS == touch_key_scan_status)
 280          //     {
 281          //         // å¦‚æœæ˜¯æ­£åœ¨å¤„ç†çŸ­æŒ‰
 282          //         bit flag_is_double_click = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦æœ‰æŒ‰é”®åŒå‡»
 283          
 284          //         if (TOUCH_KEY_ID_1 == touch_key_last)
 285          //         {
 286          //             // å¦‚æœKEY1è¢«è§¦æ‘¸
 287          //             flag_is_double_click = __is_double_click(touch_key_last);
 288          //             if (flag_is_double_click)
 289          //             {
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         06/03/2025 17:12:24 PAGE 6   

 290          //                 // å¦‚æœæœ‰æŒ‰é”®åŒå‡»
 291          //                 printf("k1 double press\n");
 292          // #if USE_MY_DEBUG
 293          //                 printf("k1 double press\n");
 294          // #endif
 295          //                 // send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY1); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€
             -¼
 296          //             }
 297          //             else
 298          //             {
 299          //                 // å¦‚æœæ²¡æœ‰æŒ‰é”®åŒå‡»ï¼Œè¯´æ˜æ˜¯çŸ­æŒ‰
 300          //                 printf("k1 press\n");
 301          // #if USE_MY_DEBUG
 302          //                 printf("k1 press\n");
 303          // #endif
 304          //                 // send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY1); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€¼
 305          //             }
 306          
 307          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE; // ç­‰å¾…æŒ‰é”®æ
             -¾å¼€
 308          //         }
 309          //         else if (TOUCH_KEY_ID_2 == touch_key_last)
 310          //         {
 311          //             // å¦‚æœKEY2è¢«è§¦æ‘¸
 312          //             flag_is_double_click = __is_double_click(touch_key_last);
 313          //             if (flag_is_double_click)
 314          //             {
 315          //                 // å¦‚æœæœ‰æŒ‰é”®åŒå‡»
 316          //                 printf("k2 double press\n");
 317          // #if USE_MY_DEBUG
 318          //                 printf("k2 double press\n");
 319          // #endif
 320          //                 // send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY2); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€
             -¼
 321          //             }
 322          //             else
 323          //             {
 324          //                 // å¦‚æœæ²¡æœ‰æŒ‰é”®åŒå‡»ï¼Œè¯´æ˜æ˜¯çŸ­æŒ‰
 325          //                 printf("k2 press\n");
 326          // #if USE_MY_DEBUG
 327          //                 printf("k2 press\n");
 328          // #endif
 329          //                 // send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY2); // å‘é€å¸¦æœ‰çŠ¶æ€çš„é”®å€¼
 330          //             }
 331          
 332          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE; // ç­‰å¾…æŒ‰é”®æ
             -¾å¼€
 333          //         }
 334          //     }
 335          
 336          //     if (TOUCH_KEY_SCAN_STATUS_IS_HANDLE_LONG_PRESS == touch_key_scan_status)
 337          //     {
 338          //         // å¤„ç†é•¿æŒ‰
 339          //         if (TOUCH_KEY_ID_1 == touch_key)
 340          //         {
 341          //             // å¦‚æœKEY1è¢«è§¦æ‘¸
 342          //             printf("k1 long press\n");
 343          // #if USE_MY_DEBUG
 344          //             printf("k1 long press\n");
 345          // #endif
 346          //             // send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY1);
 347          //         }
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         06/03/2025 17:12:24 PAGE 7   

 348          //         else if (TOUCH_KEY_ID_2 == touch_key)
 349          //         {
 350          //             // å¦‚æœKEY2è¢«è§¦æ‘¸
 351          //             printf("k2 long press\n");
 352          // #if USE_MY_DEBUG
 353          //             printf("k2 long press\n");
 354          // #endif
 355          //             // send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY2);
 356          //         }
 357          
 358          //         touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_HANDLE_HOLD_PRESS; // è·³è½¬åˆ°é•¿æŒ‰æŒç»­
 359          //     }
 360          
 361          //     if (TOUCH_KEY_SCAN_STATUS_IS_HANDLE_HOLD_PRESS == touch_key_scan_status)
 362          //     {
 363          //         // å¤„ç†é•¿æŒ‰æŒç»­
 364          
 365          //         if (touch_key_last == touch_key)
 366          //         {
 367          //             touch_time_cnt += TOUCH_KEY_SCAN_CIRCLE_TIMES;
 368          //             if (TOUCH_KEY_ID_1 == touch_key)
 369          //             {
 370          //                 if (touch_time_cnt >= HOLD_PRESS_TIME_THRESHOLD_MS)
 371          //                 {
 372          //                     touch_time_cnt = 0;
 373          //                     printf("k1 continue press\n");
 374          // #if USE_MY_DEBUG
 375          //                     printf("k1 continue press\n");
 376          // #endif
 377          //                     // send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY1);
 378          //                 }
 379          //             }
 380          //             else if (TOUCH_KEY_ID_2 == touch_key)
 381          //             {
 382          //                 if (touch_time_cnt >= HOLD_PRESS_TIME_THRESHOLD_MS)
 383          //                 {
 384          //                     touch_time_cnt = 0;
 385          //                     printf("k2 continue press\n");
 386          // #if USE_MY_DEBUG
 387          //                     printf("k2 continue press\n");
 388          // #endif
 389          //                     // send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY2);
 390          //                 }
 391          //             }
 392          
 393          //             // delay_ms(1);
 394          //         }
 395          //         else
 396          //         {
 397          //             // å¦‚æœä¹‹å‰æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸å½“å‰æ£€æµ‹åˆ°çš„æŒ‰é”®ä¸ä¸€è‡´ï¼Œ
 398          //             // è¯´æ˜ å¯èƒ½æ¾å¼€äº†æ‰‹ æˆ–æ˜¯ ä¸€åªæ‰‹æŒ‰ä½äº†åŸæ¥çš„æŒ‰é”®å¦ä¸€åªæ‰‹æŒ‰äº†å…¶ä
             -»–æŒ‰é”®
 399          
 400          //             // è·³è½¬åˆ°ç­‰å¾…é•¿æŒ‰æ¾å¼€
 401          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE;
 402          //         }
 403          //     }
 404          
 405          //     if ((TOUCH_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE == touch_key_scan_status) ||
 406          //         (TOUCH_KEY_SCAN_STATUS_IS_WAIT_SHORT_PRESS_RELEASE == touch_key_scan_status))
 407          //     {
 408          //         // å¦‚æœæ˜¯ç­‰å¾…æŒ‰é”®æ¾å¼€
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         06/03/2025 17:12:24 PAGE 8   

 409          //         static volatile u16 loose_cnt = 0; // å­˜æ”¾æ¾æ‰‹è®¡æ•°å€¼
 410          
 411          //         if (touch_key == 0)
 412          //         {
 413          //             loose_cnt += TOUCH_KEY_SCAN_CIRCLE_TIMES;
 414          //             delay_ms(1);
 415          //         }
 416          //         else
 417          //         {
 418          //             // åªè¦æœ‰ä¸€æ¬¡æ£€æµ‹åˆ°æŒ‰é”®ï¼Œè¯´æ˜æ²¡æœ‰æ¾å¼€æ‰‹
 419          //             loose_cnt = 0;
 420          //         }
 421          
 422          //         if (loose_cnt >= LOOSE_PRESS_CNT_MS) // è¿™é‡Œçš„æ¯”è¾ƒå€¼éœ€è¦æ³¨æ„ï¼Œä¸èƒ½å¤§äºå˜é‡ç±»å
             -‹å¯¹åº”çš„æœ€å¤§å€¼
 423          //         {
 424          //             loose_cnt = 0; // æ¸…ç©ºæ¾æ‰‹è®¡æ•°
 425          //             // å¦‚æœ xx mså†…æ²¡æœ‰æ£€æµ‹åˆ°æŒ‰é”®æŒ‰ä¸‹ï¼Œè¯´æ˜å·²ç»æ¾å¼€æ‰‹
 426          
 427          //             if (TOUCH_KEY_SCAN_STATUS_IS_WAIT_LONG_PRESS_RELEASE == touch_key_scan_status)
 428          //             {
 429          //                 if (TOUCH_KEY_ID_1 == touch_key_last)
 430          //                 {
 431          //                     printf("k1 long press loose\n");
 432          // #if USE_MY_DEBUG
 433          //                     printf("k1 long press loose\n");
 434          // #endif
 435          //                     // send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY1);
 436          //                 }
 437          //                 else if (TOUCH_KEY_ID_2 == touch_key_last)
 438          //                 {
 439          //                     printf("k2 long press loose\n");
 440          // #if USE_MY_DEBUG
 441          //                     printf("k2 long press loose\n");
 442          // #endif
 443          //                     // send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY2);
 444          //                 }
 445          //             }
 446          
 447          //             touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_IS_END; // è·³è½¬åˆ°æ”¶å°¾å¤„ç†
 448          //         }
 449          //     }
 450          
 451          //     if (TOUCH_KEY_SCAN_STATUS_IS_END == touch_key_scan_status)
 452          //     {
 453          //         // æ”¶å°¾å¤„ç†
 454          //         touch_key = 0;
 455          //         touch_key_last = 0;
 456          //         touch_time_cnt = 0;
 457          
 458          //         touch_key_scan_status = TOUCH_KEY_SCAN_STATUS_NONE;
 459          //     }
 460          // #endif
 461          // }
 462          
 463          // void touch_key_handle(void)
 464          // {
 465          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    129    ----
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         06/03/2025 17:12:24 PAGE 9   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     31       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
